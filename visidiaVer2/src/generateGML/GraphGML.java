package generateGML;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;

public class GraphGML {

	private static final int VALEUR_MIN = 0;
	private static final int VALEUR_MAX = 500;
	ArrayList<Node> nodes = new ArrayList<Node>();
	ArrayList<Edge> edges = new ArrayList<Edge>();
	private double maxValueEdges = 0;
	private double minValueEdges = Double.MAX_VALUE;

	public GraphGML(int nbNodes, String type, int averageNeighbor) {
		System.out.println("nbNodes" + nbNodes);
		if (type.equals("square")) {
			addNodes(nbNodes);
			addEdges(nbNodes, averageNeighbor);

		}
	}

	private void addEdges(int nbNodes, int averageNeighbor) {
		float seille[]={62,44,34,33,27,25,23,21,21,21,11,11,11,11,11,11,11,11}; //pour graph de 500x500
		//float seille[]={250,44,34,33,27,25,23,21,21,21,11,11,11,11,11,11,11,11}; //pour graph de 1000x1000
		
		int nbEdgesMax = Math.min(nbEdgesClique(nbNodes), (int) (nbNodes * averageNeighbor) / 2);
		System.out.println(nbNodes + " " + nbEdgesMax);
		boolean full = false;
		Edge currentEdge =null; 
		for (int i = 0; i < nbNodes - 1; i++) {
			for (int j = i; j < nbNodes; j++) {
				currentEdge=new Edge(nodes.get(i), nodes.get(j));
				if(currentEdge.getValue()<seille[(nbNodes/1000)-1]){
					full = edges.size() >= nbEdgesMax;
					maxValueEdges = Math.max(maxValueEdges,	currentEdge.getValue());
					minValueEdges = Math.min(minValueEdges,currentEdge.getValue()	);
					if (!full) {

						edges.add(new Edge(nodes.get(i), nodes.get(j)));

					} else {
						if (edges.get(edges.size() - 1).getValue() > currentEdge.getValue()) {
							Collections.sort(edges);
							// System.out.println(edges.get(edges.size()-1).getValue()+">"+currentEdge.getValue());
						
							//System.out.println((edges.get(edges.size() - 1)).getValue());
							edges.remove(edges.size() - 1);
							edges.add(edges.size() - 1, currentEdge);
			
						}
					}
				}

			}

		}
		System.out.println(" "+(edges.get(edges.size() - 1)).getValue()
				+" "+(edges.get(edges.size() - 1)).getValue()
				+" "+(edges.get(edges.size() - 2)).getValue()
				+" "+(edges.get(edges.size() - 3)).getValue()
				+" ************"
				//+" "+(edges.get(1000)).getValue()
				//+" "+(edges.get(10000)).getValue()
				//+" "+(edges.get(15000)).getValue()
				
				+" ************"
				);

	}

	private int nbEdgesClique(int nbNodes) {
		int k = (nbNodes - 1) / 2;
		if (((nbNodes - 1) % 2) == 1) {
			return (2 * k * (k + 1));
		} else {
			return (k * (2 * k + 1));
		}

	}

	private void addNodes(int nbNodes) {
		int i = 0;
		for (; i < 6; i++) {
			nodes.add(new Node(i, (i * VALEUR_MAX) / 10, (i * VALEUR_MAX) / 10, new String("A")));
		}
		for (; i < 10; i++) {
			nodes.add(new Node(i, (5 * VALEUR_MAX) / 10, VALEUR_MAX - ((i * VALEUR_MAX) / 10), new String("A")));
		}
		nodes.add(new Node(i, 0, VALEUR_MAX / 3, new String("A")));// node10
		i++;
		nodes.add(new Node(i, 0, VALEUR_MAX / 2, new String("A")));// node
																	// 11
		i++;
		// Line 0
		int pas[] = { 0, 2, 5, 8, 10 };
		for (int j = 0; j < pas.length; j++) {
			for (int j1 = 0; j1 < pas.length; j1++) {
				Node node = new Node(i, (VALEUR_MAX / 10) * pas[j], (VALEUR_MAX / 10) * pas[j1], new String("B"));

				nodes.add(node);
				i++;

			}

		}
		nodes.add(new Node(i, (VALEUR_MAX / 10), (VALEUR_MAX / 10), new String("B")));
		i++;
		nodes.add(new Node(i, (VALEUR_MAX / 10) * 9, (VALEUR_MAX / 10), new String("B")));
		i++;
		nodes.add(new Node(i, (VALEUR_MAX / 10), (VALEUR_MAX / 10) * 9, new String("B")));
		i++;
		nodes.add(new Node(i, (VALEUR_MAX / 10) * 9, (VALEUR_MAX / 10) * 9, new String("B")));
		i++;
		for (int j = i; j < nbNodes; j++) {
			int x = random(0, VALEUR_MAX);
			int y = random(0, VALEUR_MAX);
			nodes.add(new Node(i, x, y, new String("C")));
			i++;
		}

	}

	private int random(int mini, int max) {
		return (int) (Math.random() * (max - mini + 1)) + mini;

	}

	public void save(String fileName) {
		File f = new File(fileName);

		try {
			FileWriter fw = new FileWriter(f);
			fw.write("graph [\n       comment \"Generated by ViSiDiA\"\ndirected 0\n");
			for (int i = 0; i < nodes.size(); i++) {
				print(fw, nodes.get(i));
			}
			for (int i = 0; i < edges.size(); i++) {/* i < nodes.size()&& */
				print(fw, edges.get(i));
			}
			fw.write("]");
			fw.close();
		} catch (IOException exception) {
			System.out.println("Erreur lors de Lecture/ecriture fichier : " + exception.getMessage());
		}

	}

	private void print(FileWriter fw, Edge edge) {
		try {
			fw.write("   edge [\n");
			fw.write("      source " + edge.getSrc().getId() + "\n");
			fw.write("      target " + edge.getTgt().getId() + "\n");
			fw.write("      label \"\"\n");
			fw.write("      weight 1.0\n");
			fw.write("   ]" + "\n");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	private void print(FileWriter fw, Node node) {

		try {
			fw.write("   node [\n");
			fw.write("      id " + node.getId() + "\n");
			fw.write("      label \"" + node.getType() + "\"\n");
			fw.write("      graphics [\n");
			fw.write("         x " + node.getX() + "\n");
			fw.write("         y " + node.getY() + "\n");
			fw.write("      ]\n");
			fw.write("   ]\n");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
